# 퀵 정렬

병합 정렬처럼 퀵 정렬도 분할 정복(divide-and-conquer) 전략을 사용하는 재귀 알고리즘이다. 병합 정렬이 결합 단계에서 중요한 작업을 하였다면, 퀵 정렬은 반대인데, 모든 중요한 작업은 분할 단계에서 일어난다. 퀵 정렬은 결합 단계에서 아무것도 하지 않는다.

빠른 정렬은 제저리에서 수행된다. 그리고 최악의 경우에 대한 수행 시간은 선택 정렬이나 삽입 정렬처럼 Θ(n^2)로 좋지 않다. 하지만 빠른 정렬의 평균 수행 시간은 병합 정렬만큼 좋은 Θ(n log2 n)이다.

array[0..n-1] 인 하위 배열 array[p..r]을 정렬한다고 생각해보자.

1. 하위 배열 array[p..r]에서 아무 요소를 골라 분할한다. 이 요소를 피벗이라고 한다.
   array[p..r]안의 요소들을 재배열하여 array[p..r]안의 모든 요소 중 피벗보다 작거나 같은 요소는 피벗의 왼쪽으로 보내고, 나머지 요소는 모두 오른쪽으로 보낸다. 이 과정을 **파티션하기**라고 한다. 이 과정에서, 피벗의 왼쪽과 오른쪽 요소들이 어떤 순서로 배열되는지는 상관 없다.

2. array[p..q-1] (피벗보다 작거나 같은, 즉 피벗의 왼쪽에 있는 모든 요소들)과 array[q+1..r] (피벗보다 큰, 즉 피벗의 오른쪽에 잇는 노든 요소들)을 재귀적으로 정렬하여 정복한다.

3. 아무것도 하지 않으므로써 결합한다. 정복 단계에서 한 번 재귀적으로 정렬했다면 끝난 것이다.
   array[p..q-1]에 있는 피벗 왼쪽의 모든 요소는 피벗보다 작거나 같고, 정렬되어 있다. array[q+1..r]에 있는 피벗 오른쪽의 모든 요소는 피벗보다 크고, 정렬되어있다. array[p..r]의 모든 요소는 정렬될 수밖에 없다.

탈출조건: 탈출 조건은 병합 정렬에서와 같이 요소가 2 개 미만인 하위 배열이 된다. 병합 정렬에서는 아무것도 없는 하위 배열이 없었지만, 빠른 정렬에서는 만일 하위 배열 내의 다른 요소들이 모두 피벗값보다 작거나 모두 클 경우 아무것도 없는 하위 배열이 있을 수 있다.

# 선형 시간 분할하기

퀵 정렬에서 중요한 부분은 하위 배열 array[p..r]을 하위 배열에서 얻은 피벗값을 중심으로 파티션을 나누는 분할 단계이다. 하위 배열 내 어떤 요소이든 피벗으로 고를 수는 있지만 하위 배열에서 가장 오른쪽 요소 A[r]을 피벗값으로 고르면 파티셔닝을 구현하기가 쉽다.

피벗값을 선택하게 되면 하위 배열 각각의 요소를 왼쪽에서 오른쪽으로 피벗과 비교해 나감으로써 하위 배열을 분할한다. 두 개의 인덱스 q 와 j 를 갖고 하위 배열을 4 개 그룹으로 나눈다.

n 개 요소를 가진 하위 배열의 파티션을 나눈는 데는 Θ(n)시간이 걸린다. 각 요소 array[j]는 한 번씩 피벗값과 비교된다. array[j]는 array[q]와 자리를 바꾸거나 바꾸지 않을 수 있고 q 도 증가되거나 증가되지 않을 수 있다. j 는 항상 증가된다. 하위 배열의 한 요소당 실행되는 총 코드 줄의 수는 상수이다. 하위 뱅려에는 n 개의 요소가 있으므로 파티션을 나누는데 드는 시간은 선형적 시간: Θ(n)이다.

# 퀵 정렬 구현하기

partition function

1. array[r]보다 작은 수와 큰 수로 나누는 partition 함수
2. q,j 는 처음에는 p 로 같음
3. array[j]가 array[r]보다 작으면 array[j]와 array[p]를 서로 바꾸고 j 와 q 를 ++ 해준다. -> r 보다 작은 수를 q 인덱스를 기준으로 왼쪽 큰 수를 오른쪽으로 놓는다. 왼쪽과 오른쪽에 있는 숫자들은 순서대로 정렬되어 있진 않음
4. 아니라면 j 만 ++ 해준다.
5. j 가 r 보다 작을때까지 반복한다.
   한칸 한칸씩 밀면서 결국 p..q 는 r 보다 작은 수 q+1..j 는 r 보다 큰 수로 정렬하는 것이다.
6. 마지막에 q 와 r 을 바꾼다. -> r 을 기준으로 q 의 오른쪽과 왼쪽으로 정렬하였으므로 q 자리에 r 을 넣음
   quickSort function

partition 함수의 반환값인 q 는 q 를 기준으로 q 의 왼쪽은 q 보다 작은 수 오른 쪽은 q 보다 큰 수이다. q 를 기준으로 다시 quickSort 함수를 반복해서 실행하면 작은 순서대로 정렬이 된다.

```js
function swap(array, firstIndex, secondIndex) {
  const temp = array[firstIndex];
  array[firstIndex] = array[secondIndex];
  array[secondIndex] = temp;
}

function partition(array, p, r) {
  let q = p;
  for (let j = p; j < r; j++) {
    if (array[j] < array[r]) {
      swap(array, j, q);
      q++;
    }
  }
  swap(array, q, r);
  return q;
}

function quickSort(array, p, r) {
  if (p < r) {
    q = partition(array, p, r);
    quickSort(array, p, q - 1);
    quickSort(array, q + 1, r);
  }
}
```
