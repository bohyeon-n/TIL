# 병합 정렬

## 분할 정복식 알고리즘

선택 정렬과 삽입 정렬의 최대 실행 시간은 Θ(n^2)으로 나타낼 수 있다. 입력하는 배열의 크기가 크다면 이 알고르즘으로 정렬하는 데 매우 오랜시간이 걸릴 수 있다.
병합 정렬의 실행시간은 모든 경우에 대해 Θ(n lg n)으로, 빠른 정렬의 최대 시간은 Θ(n^2)이지만 가장 빠르면 Θ(n lg n)으로 나타낸다.

## 분할 정복(Divide-and-conquer)

병합 정렬과 빠른 정렬 두 가지 정렬 방법은 모두 재귀 알고리즘 설계 패러다임을 기반으로 삼고 있다. 분할 정복으로 통칭하는 이 패러다임은 한 문제를 유형이 비슷한 여러 개의 하위 문제로 나누어 재귀적으로 해결하고 이를 합쳐 원래 문제를 해결한다. 분할 정복 방식이 하위 문제를 재귀적으로 해결하기 때문에 하위 문제 각각은 원래 문제보다 범위가 작아야 하며 하위 문제는 각 문제마다 탈출 조건이 존재해야 한다.

1. 분할: 원래 문제를 분할하여 비슷한 유형의 더 작은 하위 문제들로 나눈다.
2. 정복: 하위 문제 각각을 재귀적으로 해결한다. 하위 문제의 규모가 충분히 작으면 문제를 탈출 조건으로 놓고 해결한다.
3. 합치기: 하위 문제들의 답을 합쳐서 원래 문제를 해결한다.

분할 정복 알고리즘 단계를 분할, 정복, 합치기 세 개로 나누면 쉽게 기억할 수 있다.
분할 정복 알고리즘은 최소한 두 개의 하위 문제를 생성하므로 여러번 재귀 호출을 한다.

## 병합 정렬이란?

정렬 과정에서 분할 정복 알고리즘을 사용하기 때문에 하위 문제들을 어떻게 구성해야 하는지 결정해야 한다. 궁극적인 목표는 전체 배열을 정렬하는 것이다. 하위 문제는 하위 배열을 정렬하는 것이라고 하자. 특히 하위 문제를 인덱스 p 에서 시작하여 인덱스 r 까지 정렬하는 것이라고 하자. 특히 하위 문제를 인덱스 p 에서 시작하여 인덱스 r 까지 정렬해야 하는 문제로 간주한다.

1. 분할: p 와 r 의 중간 q 를 찾는다. p 와 r 을 더해서 2 로 나눈 후 내림하여 정수로 만든다.
2. 정복: array[p...q], array[q+1...r]을 재귀적으로 정렬한다. 분할 단계에서 만들어진 두 하위 문제 각각에 있는 하위 배열을 재귀적으로 정렬한다.
3. 결합: 정렬된 두 하위 배열을 하나의 정렬된 하위 배열인 array[p...r]로 결합한다.

탈출 조건은 2 개 미만의 요소가 포함된 하위 배열로, 이는 p >= r 인 경우이다. 요소가 하나도 없거나 하나만 있는 배열은 이미 정렬되어 있는 것과 같다. 그러므로 p < r 일 때만 분할-정복-결합 과정을 거친다.

**예제**
[14,7,3,12,9,11,6,2]

1. 분할 단계에서 q = 3 이다.
2. 정복 단계에서 [14, 7, 3, 12],[9, 11, 6, 2]를 정렬한다. 그러므로 완전한 배열은 [3,7,12,14,2,6,9,11]이 된다.
3. 마지막으로 결합 단계에서는 앞 쪽과 뒤 쪽으로 된 두 정렬된 하위 배열을 병합해서 마지막으로 정렬된 배열 [2,3,6,7,9,11,12,14]를얻는다.

## 응용: 병합 정렬 구현

```js
const merge = function(array, p, q, r) {
  //정의되어 있음
};
var mergeSort = function(array, p, r) {
  if (p < r) {
    const q = Math.floor((r - p) / 2) + q;
    mergeSort(array, p, q);
    mergeSort(array, q + 1, r);
    merge(array, p, q, r);
  }
};
```

## 선형 시간 병합하기

이웃한 두 정렬된 하위 배열을 하나의 정렬된 하위 배열로 병합하는 merge 함수를 구현해야 한다.
두 하위 배열에 총 n 개의 요소가 있다고 하면, 이들을 하나로 병합하기 위해 각 요소를 검사해야 하므로 최상의 경우 병함시간이 Θ(n)이 된다. Θ(n) 시간이 걸린다는 것은 걸리는 것과 걸리는 시간은 하위 배열의 크기와 비례한다는 것을 알아냈다. 그 이유를 알아보자. 병합에는 세 가지 부분이 있다.

1. array[p..r] 에 있는 요소 각각을 lowerHalf 나 highHalf 에 붙여넣기 한다.
2. lowerHalf 와 highHalf 에서 모두 붙여지지 않은 어떤 요소가 존재한다면 이 중 처음 나오는 두 개의 값을 비교하여 더 작은 값을 array 에 붙여넣는다.
3. lowerHalf 와 highHalf 중 하나의 모든 요소가 array 에 복사되었다면 다른 임시 배열의 남은 모든 요소들을 다시 array 에 붙여넣는다.

위의 각 단계를 실행하려면 요소 한 개당 일정한 수 만큼의 코드가 필요하다. 각 요소는 1 단계에서 정확히 한 번씩 배열에서 lowerHalf 또는 highHalf 중 하나로 복사된다. 2 단계에서의 비교는 일정한 시간이 소요된다. 이 단계에서는 두 요소만을 비교하고 각 요소는 최대 한 번만 비교에서 '이기게'되기 때문이다. 2 단계와 3 단계에서 각 요소는 정확히 한 번 array 로 다시 복사된다. 코드 한 줄을 실행하는 데 요소 당 일정한 시간이 걸리고 하위 배열 array[p..q]에는 n 개의 요소가 있기 때문에 병합하는 데 걸리는 시간은 Θ(n) 이다.(점근적 표기법)

## 응용: 병합 구현

```js
const merge = function(array, p, q, r) {
  const lowHalf = [];
  const highHalf = [];

  let k = p;
  let i;
  let j;
  for (i = 0; k <= q; i++, k++) {
    low[i] = array[k];
  }
  for (j = 0; k <= r; j++, k++) {
    highHalf[j] = array[k];
  }
  k = p;
  i = 0;
  j = 0;

  while (i < lowHalf.length && j < highHalf.length) {
    if (lowHalf[i] < highHalf[j]) {
      array[k] = lowHalf[i];
      i++;
    } else {
      array[k] = highHalf[j];
      j++;
    }
    k++;
  }
  while (i < lowHalf.length) {
    array[k] = lowHalf[i];
    i++;
    k++;
  }
  while (j < highHalf.length) {
    array[k] = highHalf[j];
    j++;
    k++;
  }
};
```

## 병합 정렬 분석하기

n 개의 요소를 병합할 때 merge 함수가 Θ(n)번 실행된다면, mergeSort 가 Θ(nlog2n)번 실행된다는 것을 어떻게 보일 수 있을까? 분할 정복 세 부분과 그것의 소요시간을 어떻게 계산해야 하는지 생각해보자.
전체 배열에서 n 개의 요소를 정렬한다고 가정하자.

1. 분할 단계는 하위 배열의 크기에 상관없이 일정한 시간이 걸린다. 결국 분할 단계는 인덱스 p 와 r 의 중심적인 q 를 계산한다. big-Θ 표기법에서 Θ(1)로 소요시간이 나타났다는 것을 기억하자.
2. 각각 n/2 개의 요소를 가진 두 개의 하위 배열을 재귀적으로 정렬하는 정복 단계에도 어떤 시간이 걸린다. 하지만 하위 문제를 계싼할 떄 함께 계산할 것이다.
3. 결합단계에서 Θ(n) 시간 동안 총 n 개의 요소를 병합한다.

분할 단계와 결합 단계를 함께 생각해보자. 분할 단계의 실행시간인 Θ(1)은 결합단계의 Θ(n) 실행시간과 비교하면 낮은 차수의 항이다. 그러므로 분할 단계와 결합 단계를 합하여 Θ(n)시간이 걸린다고 할 수 있다. 확실하게 하기 위해 분할 단계와 결합단계를 합하여 cn 시간이 걸린다고 하자.

만일 n > 1 일 경우 n 은 항상 짝수라고 가정한다면 n/2 을 고려할 때 이는 정수가 된다. 그러므로 n 요소를 가진 하위 배열에서 mergeSort 를 실행하는 시간은 (n/2)요소를 가진 하위 배열에서 mergeSort 를 실행 시간(정복 단계)의 두 배와 cn 을 합한 것이라 생각해 볼 수 있습니다.

이제 n/2 요소에서 두 번의 재귀적 호출을 실행하는 데 드는 시간에 대해 알아보자.
이 두 재귀적 호출 각각에는 (n/2 을 반으로 나누어야 하기 때문에 )(n/4)개 요소의 하위 배열에 mergeSort 를 실행하는 시간의 2 배에 병합한는 데 드는 cn/2 을 더한 시간이 소요된다. n/2 크기의 두 개의 하위 문제가 있고, 각각은 병합하는 데 cn/2 시간이 들기 때문에 n/2 크기의 하위 문제를 병합하는 데 드는 총 시간은 2\*cn/2 = cn 이다.

![트리](https://ka-perseus-images.s3.amazonaws.com/5fcbebf66560d8fc490de2a0d8a0e5b1d65c5c54.png)

하위 문제가 작아질수록 하위 문제의 수는 재귀과정의 각 단계마다 배가 되지만 병합 시간은 반으로 줄게 된다. 배가 되고 반으로 줄어들어 서로의 효과가 상쇄되기 때문에 각 재귀과정 단계에서 총 병합 시간은 cn 이 된다. 결국은 하위 문제의 크기를 1 로 줄이는 탈출 조건에 이르게 된다. 크기 1 의 하위 배열을 정렬하려면 p < r 인지 여부를 검사해야 하고 이 과정에 시간이 걸리기 때문이 Θ(1)가 소요된다. 크기 1 의 하위 배열이 몇 개나 있을까? 처음 시작할 때 n 개 요소로 시작했으므로 하위 배열은 n 개 있다. 각각의 탈출 조건에는 Θ(1)시간이 소요되기 때문에 모두 합해 탈출 조건에 cn 시간이 걸린다고 하자.

이제 각 하위 문제 크기에서 병합 과정에 얼마나 걸릴지 알았다. mergeSort 에 소요되는 총 시간은 모든 단계에서의 병합시간을 합한 것이다.
트리에 l 레벨이 있다면 총 병합시간은 l\*cn 이다. l 은 무엇일까? 이제까지 n 크기 문제의 하위 문제로 시작해서 하위 문제가 1 로 줄어들 때까지 반복적으로 이를 반으로 줄였다. l = log2n + 1 이다. 예를 들어 n = 8 이라면 log2n + 1 = 4 이고 트리는 n = 8,4,2,1 의 4 레벨로 이루어져 있다. 그러면 mergeSort 에 드는 총 시간은 cn(log2n +1)이다. 이 샐행 시간을 나타내기 위해 big-Θ 표기법을 사용한다면 Θ(nlog2n)이 된다.

병합정렬은 제자리에서 작동하지 않는다(lowwHalf, highHalf 복사본) 그에 반해 선택 정렬과 삽입 정렬은 어떤 경우라도 배열 요소를 상수 개수 이상 복사하지 않기 때문에 모두 제자리에서 작동한다. 저장 공간이 부족한 시스템이라면 알고리즘이 제자리에서 작동하는지 여부에 대해서도 고려한다.
