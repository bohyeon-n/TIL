# 재귀 알고리즘

## 재귀란?

어떤 문제를 해결하기 위해 알고리즘을 설계할 때 동일한 문제의 조금 더 작은 경우를 해결하므로써 그 문제를 해결하는 것이다. 문제가 간단해져서 바로 풀 수 있는 문제로 작아질 때까지 말이다. 이런 테크닉을 재귀라고 한다.

## 팩토리얼 함수

n 의 팩토리얼은 n!이라고 표시한다. 이는 1 부터 n 까지의 정수를 곱하는 단순한 연산이다. 예를 들어 5!는 1*2*3*4*5, 즉 120 이다.

**얼마나 다양한 방법이 있는지 구할 때**
팩토리얼 함수는 사물의 순서를 정할 때 얼마나 많은 방법이 있는지, 또 어떤 것들을 조합할 때 얼마나 다양한 방법이 있는지 구할 때 매우 유용하다. 예를 들어 n 개의 물건을 배열하는 방법은 몇 개나 될까? 첫 번째 물건을 배열하는 방법은 n 가지 이다. 이런 각각의 n 개의 선택에 대해, 두 번쨰 항목은 n - 1 개의 선택을 할 수 있다. 그러므로 첫 번째와 두 번째 물건을 차례대로 배열하는 방법은 n\*(n - 1)가지이다. 마지막으로 한 가지만 남을 때까지 계속 하면 이를 간단히 n!(n 팩토리얼)로 표현할 수 있다.

**여러 개 중에서 몇 개만 선택하는 경우의 수를 셀 때**
팩토리얼 함수가 유용한 또 다른 예는 여러 개 중에서 몇 개만 선택하는 경우의 수를 셀 때 이다. 예를 들어 여행을 갈 때 가져갈 티셔츠를 고른다고 하면, 티셔츠가 n 개 있지만 그 중 k 개만 가져갈 수 있다고 하자. n 장의 티셔츠 중 k 개의 티셔츠를 고를 수 있는 가지수는 얼마나 될까?
해답은 n!/(k!\*(n - k)!)이다.

팩토리얼 함수는 모든 양의 정수와 0 에 대해 정의된다. 0!의 값은 무엇이어야할까? 이는 1 보다 크거나 같고 0 보다 작거나 같은 모든 정수들의 곱이다. 그렇지만 그런 정수는 존재하지 않는다. 그러므로 0!은 곱셈의 항등원인 1 과 같다고 정의한다. (0!0!=1) 이라고 정의하는 것은 n 가지 중 k 개를 고르는 문제를 위한 공식에 적합하다.
n 개 중에서 n 개를 고르는 방법이 얼마나 있는지 알고 싶다고 하자. 한가지이다. 그럼 n!/(n!*(n - n)!)은 1 이 되어야 한다. 그런데 (n - n)!은 0 이다. 이제 n!/(n!*0)은 1 이 되어야 한다. n!을 분자와 분수에서 모두 약분하면 1/(0!)이 1 이 되어야 한다. 실제로 0! = 1 이기 때문이다.

n !은 n = 0 일 때는 1 이다. n 이 양수일 때는 1•2•••(n -1)•n 과 같다.

## 응용: 반복적인 팩토리얼

```js
const factorial = function(n) {
  let result = 1;
  for (let i = n; i > 0; i--) {
    result *= i;
  }
  return result;
};
```

## 응용: 재귀 팩토리얼

```js
const factorial = function(n) {
  return n === 0 ? 1 : n * factorial(n - 1);
};
```

```js
const factorial = function(n) {
  if (n === 0) {
    return 1;
  }
  return n * factorial(n - 1);
};
```

## 재귀 알고리즘의 속성

> 어떤 문제를 해결하기 위해, 문제의 범위보다 약간 좁은 하위 문제를 해결한다. 그 다음에 하위 문제에 대한 해답을 이용하여 원래 문제를 해결한다.

n!을 계산할 때 n!을 바로 계산하는 대신 이보다 더 작은 (n -1)!(범위가 더 좁은 하위 문제)를 계산하였고, 이에 대한 해답을 이용하여 n!의 값을 계산하였다.

재귀 알고리즘이 실제로 작동하려면 범위가 더 좁은 하위 문제가 base case 에 도달하여 재귀함수가 끝날 수 있어야 한다. n!계산할 때, 하위 문제는 점점 작아져 0!에 도달한다. 이런 base case 가 반드시 있어야 한다.

만약에 n 의 값이 음수가 아니라고 해도 하위 문제의 값을 점점 작아지도록 만들지 않으면 절대로 답을 구할 수 없다.

재귀의 반복 개념은 다음과 같이 두 개의 간단한 규칙으로 간추릴 수 있다.

1. 재귀의 호출은 같은 문제 내에서 더 범위가 작은 값, 즉 하위 문제에 대해 이루어져야 한다.
2. 재귀 함수 호출은 더이상 반복되지 않은 base case 에 도달해야 한다.
