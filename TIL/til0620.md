# 고차 컴포넌트 

component를 받아서 컴포넌트를 반환하는 함수 
class도 함수도 모두 값이기 때문에 
const inetityHOC = Component => {s
  return class extends React.Component {
    render() {
      return <Component/>
    }
  }
}
export default identityHOC(TodoContainer)



Component => {
  return class extends React.Component {
    render() {
      return <Component/>
    }
  }
}
이 함수는 클래스를 반환한다. 익명클래스임
앞에서 입력받는 컴포넌트를 렌더링 해주는 클래스 컴포넌트이다. 
컴포넌트를 받아서 이 컴포넌트를 사용하는 새로운 컴포넌트를 반환할 수 있다. 그 자체는 컴포넌트는 아니다. 
이런느낌이 고차컴포넌트 
이 고차 컴포넌트에는 아무런 기능이 없다. 컴포넌트를 받아서 컴포넌트를 렌더링 해주는 기능뿐.
이 기능을 활용하면, 컴포넌트의 코드 중복 문제를 해결할 수 있다. 

## Cross-Cutting Concerns
여러 페이지를 만들어야 할 때 여기에 다 같은 기능이 들어가야 하는 상황 
여러 기능들이 있고 이 기능들을 관통하는? 
여러 기능에 걸쳐서 사용되어야 하는 코드?.

```js
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // "DataSource" is some global data source
      comments: DataSource.getComments()
    };
  }

  componentDidMount() {
    // Subscribe to changes
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // Clean up listener
    DataSource.removeChangeListener(this.handleChange);
  }
// 서버에 더이상 이벤트리스너를 걸지 않아도 되므로 청소해주기
  handleChange() {
    // Update component state whenever the data source changes
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    );
  }
}
```
컨테이너 컴포넌트 
- 구독
  - 멀리서 일어날때마다 통지받는 프로그래밍 언어

조립한 새 컴포넌트를 반환하는 함수가 HOC
첫 번째 인수는 감싸지는 컴포넌트 반환할 컴포넌트
두 번째 인수는 필요한 데이터를 받아옴

    // todo라는 경로를 직접치고 들어올 수 있기 때문에 
    //  웹서비스를 만들면 로그인이 필요한 페이지들이 많을 것이다. 프로필편집, 글 작성 등 로그인 한 사용자만 들어올 수 있게 막아줘야 한다.
    // 이 코드를 굉장히 많은 곳에 작성을 해줘야 한다. 이 코드가 많이 중복될 것이다.
    // HOC적용하지 않는다면, 중복작성해야 한다. 여러 컴포넌트에 걸쳐서 같은 기능을 구현해야 할 필요가 있을 때. 특히 외부세계와 연동되는 같은 기능을 구현해야 할 필요가 있을 때
    // 사용되는 기술이 hoc기술이다. 

함수를 가지고 컴포넌트를 동적으로 만들어낼 수 있다. 
여러 곳에서 구현을 해야 한다면 withAuth를 붙여주기만 하면 되게 된다. 

todopage를 hoc로 감싸주는 것이 더 좋다(401 error)

withAuth를 페이지에 적용을 시켜라 아예 그 페이지 전체가 보이지 않는 것이 좋으니까 페이지에 적용을 시켜줘라.
어떤 놈들은 컨테이너 컴포넌트에 적용을 시켜야 하는 경우도 있을 것이다. 


합성
컴포넌트가 이미 만들어지면 변경하지 말고 조합해서 써라 감싸서 써라 

클래스 생성자 프로토타입 객체 constructor속성이 들어있었고
컴포넌트를 변경하지 말고 합성을 사용해라 

새 컴포넌트를 만들어서 문제를 해결해라 

hoc와 무관한 prop은 감싸진 컴포넌트에 넘기세요
만들어져있는 컴포넌트를 사용할 때는 프롭을 통해서 사용한다.
컴포넌트를 사용하는 방법 인터페이스. 인터페이스로서의 프롭
hoc를 통해서 컴포넌트를 업그레이드시키더라도, 원래 컴포넌트의 사용법을 바꿔서는 안된다.
새 컴포넌트를 만들어서 export default 
바깥에서 쓰는 쪽에서는 todopage를 쓰듯이 withauth에서 반환한 컴포넌트와 todopage컴포넌트는 다른 컴포넌트이다. 다만 사용하고 있을뿐이다.
사용법이라는 것이 있어서 todopage에서 프롭을 받아서 쓰고 있다면, 페이지를 쓰는 입장에서는  todopage에 이렇게 작성이 되어있으니까 바깥쪽에서 쓸 때 hoc로 둘러싸여 있더라도 상요법대로 사용할 수 있어야 한다.

객체를 통째로 prop으로 넘겨줄 수 있었다.

리액트 라우터
컴포넌트 프롭은 컴포넌트 클래스, 함수를 프롭으로 받는다. 내가 어떻게 보여주고 싶은지 지정하고 싶을 때 엘리먼트를 함수프롭에다가 만들어주면 
프롭넘겨주려면 엘리먼트를 써야 하는데....
렌더라는 프롭을 쓸 수 있다. 편의기능 
대게는 컴포넌트 프롬만써도 문제를 해결할 수있다. 

hoc에서만 사용할 수 있는 테크닉이 아니라 아무 컴포넌트에서도 사용할 숭 ㅣㅆ다.

- 
컴포넌트와 설정객체를 받아서 

hoc가 많아졌다고 한다면, 
코드지저분


render method안에서 hoc를 사용하지 마세요

reconciliation 비교조정 
리액트가 정확히 어떤 방식으로 필요한 부분만 변경하는지 알고리즘의 이름이 비교조정이다.

리액트는 컴포넌트의 종류가 바뀌면 객체를 다 날려버린다.
렌더링을 여러번 해도 유저프로바이더나 투두프로바이더는 상태를 계속 유지하고있다. 
렌더링이 다시 된다 하더라도 컴포넌트의 종류가 같으면 상태가 유지가 된다. 

컴포넌트의 종류를 보고 새로렌더링되는 컴포넌트들의 종류가 있는데, 컴포넌트의 타입이 바뀌지 않으면 스테이트를 유지한다. 

클래스가 같은지를 보고 이 상태를 유지할지말지 결저을 한다. 
렌더메소드 호출할 때마다 컴포넌트를 새로 만든다면, 상태가 계속 날라간다. 

hoc로 컴포넌트를 만들때는 한 번만 만들어주도록 코드를 작성해줘야 한다.
딱 한번만 컴포넌트가 생성되도록 

정리 맨 바깥 스코프에서 hoc를 쓰는 것이다 이렇게 생각해도 무방하다.  

hoc를 쓰실 때는 우리가 간단하게 쓸 때는 
다른 hoc를 붙여야 할 때 문제가 생긴다. 
나중에 도움이 된다. 

compose 


정적 클래스필드 
static initial = 0;
instance의 속성이 되지 않고, 클래스 속성이 된다. 

Date.now() Date 클래스의 속성이다.

d = new Date() 
d.now // undefined 

class 는 객체를 찍어낸느 틀
찍어내진 객체를 인스턴스
서로 다른 별개의 객체이다.
그냥 클래스필드를 쓰면 찍어낸 객체의 속성이 되는거고
static 틀의 속성이 된다.

prop은 컴포넌트의 사용법이다.
로그인폼의 사용법을 찾아보면(프롭을 찾아보면) 로그인컴포넌트의 사용법을 알아보렴녀, 다 찾아보고 어떻게 사용되는지 찾아봐야 한다.
많은 프롭을 받고 여기저기서 사용되고 있다면, 이 컴포넌트를 어떻게 사용되는지 알아보기 위해서 컴포넌트를 다 읽어봐야 한다. 문제임
컴포넌트의 설명서의 느낌으로 default props를 써준다.
다 default props를 붙여주자.

파셀은 의존성을 아무데서나 써도 잘알아듣는데
웹펙은 자바스크립트에 써줘야 한다. 

classnames('button', {"is-loading": true})
-> 'button is-loading'
classnames('button', {"is-loading": false})
-> 'button'
classnames({'button': true, 'is-loading': false})


어떤 순서대로 개발을 하면 좋을까????????????????

어떤 순서로 개발하느냐에 따라서 소프트웨어의 품질이 굉장히 달라질 수 있다.
조금씩 생각해서 작은 부분을 생각해나가야 잘 만들 수 있다.
큰!거 만들고 큰~거 만들면 망
폭포수 방법론: 기획 -> 디자인 -> 개발
기획은 언제나 바뀔 수 있다. 이 과정속에서 팀원들이 배우는 것들이 굉장히 많다. 만들어 보기 전에는 알 수 없는 것들이 많다. 모든 것을 예상할 순 없다.
이 과정을 거쳐야만 알 수 있는 것들이 굉장히 많기 때문에

기획 -> 디자인 -> 개발  무한 반복
애자일의 핵심 이 사이클을 계속 돈다. 이 한바퀴를도는 것을 iteration
작게 작게 나눠서 사이클을 돌아 봐야 한다.

어떤 사이클을 돌아야 할까
데이터 기획 -> 통신방식 디자인 -> 프레젠테이션 컴포넌트 프로바이더 구현 -> 컨테이너 컴포넌트 구현 

로그인 : 데이터 설계/ pc/ provider state를 어떤 식으로 가져와서 어떻게 관리할 것인가./ container component 
글목록 : 
글작성 :
댓글목록 :

순서대로 구현하고 
로그인을 구현해보면 배우는 점이 많다. 그 교훈을 얻어서 글목록을 구현하고 글 작성 댓글목록을 구현하기 이런식으로 하는 것이 좋다. 

구현해야 할 여러기능들(로그인, 글 목록 보기) 기능단위로 나눠서 개발을 해야 한다.
한 기능을 구현할 때는 적당히 기능을 완성시킨 후에 다음기능 구현으로 들어가야 한다. 

스타일 다듬기는 맨 마지막에
로그인 기능 만드는 이터레이션에서 여기서 계속 하면 일정이 늘어짐, 적당한 타이밍에 하는 것이 좋다.

보여지는 부분, 뒷 부분, 이 둘을 이어주기 
가정하지 않기 위해 나중에 연결시키는 것이 재사용성을 높일 수 있다.  pc 가정하지 않아야 재사용성을 높일 수 있음. 
접근 순서가 중요하다. 

로그인
글목록
글작성
댓글목록
프로필
