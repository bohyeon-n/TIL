# 오늘 한 일

오늘은 컴퓨터 사이언스 5 장 함수 파트를 공부하였다.

프로그래밍에서는 함수의 작동 방식을 정확히 이해하는 것이 매우 중요하다.
먼저 전역변수와 지역변수와 스택프레임을 먼저 안 후 함수를 호출할 때 인자를 전달하는 방식에 따라 실행 결과가 어떻게 달라지는지 이해해야 한다.

## 함수

### 전역 변수와 지역 변수

#### 전역 변수

젼역 변수는 전체 영역에서 접근할 수 있는 변수이다. 따라서 함수 안에서도 접근할 수 있어야 한다.

```py
g_var = 10

def func():
  print("g_var = {}".format(g_var))
if __name__ == "__main__":
  func()
```

함수 안에서 전역변수의 변경을 시도해보기

```py
g_var = 10
def func():
  g_var = 20
  print("g_var = {} in function".format(g_var))
if __name__ == "__main__":
  func()
  print("g_var = {} in main".format(g_var))

# g_var = 20 in function
# g_var = 10 in main
```

왜 전역변수의 값이 바뀌지 않았을까?
-> 함수 안에서 전역 변수 `g_var` 값의 변경을 시도하기 위해서 함수안에서 선언한 `g_var` 은 전역 변수를 변경하는 것이 아니라 함수 안에서 새로운 지역 변수 `g_var` 을 생성한 것이다.

#### 지역 변수

지역변수는 특정 지역에서만 접근 할 수 있는 변수이다. 특정 지역은 함수 내부를 의미한다. 따라서 함수 안에서 선언한 변수가 지역변수이다. 지역변수는 함수 바깥에서는 접근할 수 없고 함수가 호출될 때 생성되었다가 호출이 끝나면 사라진다.

그렇다면 함수 안에서는 전역 변수에 접근만 할 수 있고 변경은 할 수 없을까?
아니다. 함수 안에서 전역 변수를 변경하기 위해서는 특별한 문법이 필요하다.

```py
g_var = 10
def func():
  global g_var
  g_var = 20
if __name__ == "__main__":
  print("g_var : {} before".format(g_var)
  func()
  print("g_var : {} after".format(g_var)
```

#### nonlocal 키워드

함수를 정의할 때 내부에서 다른 함수를 정의할 수 있다.

```py
def outer():
  a = 10
  def inner():
    b = 20
```

inner() 함수에서 outer() 함수의 지역변수인 a 를 변경할 수 있을까? a 는 outer()함수의 지역변수이지만, inner() 함수 입장에서는 지역변수가 아니다. inner() 함수의 지역변수는 b 이다. 그렇다고 해서 inner() 함수 입장에서 outer()의 a 가 전역변수도 아니므로 global 키워드를 사용할 수도 없다.

nonlocal 키워드를 사용하기

```py
def outer():
  a = 2
  b = 3
  def inner():
    nonlocal a
    a = 100
  inner()
  print("locals in outer : a = {}, b = {}".format(a,b))
if __name__ == '__main__':
  outer()
# locals in outer: a = 100, b = 3
```

---

### 인자 전달 방식에 따른 분류

함수는 인자(argument)전달 방식에 따라 크게 값에 의한 전달(call by value)과 참조에 의한 전달(call by reference) 로 나뉘어진다.

#### 값에 의한 전달 (call by value)

```c++
#include <iostream>
using namespace std;
void change_value(int x, int value)
{
  x = value;
  cout << "x: "<<x<<"in change_value" <<endl
}
int main(void)
{
  int x = 10;
  change_value(x, 20);
  cout << "x:"<<x<<"in main"<<endl;

  return 0;
}
// x : 20 in change_value
// x: 10 in main
```

지역변수 x 값은 20 으로 바뀔 것 같지만 실행결과를 보면 예상과 다른 값이 출력된다.

함수 안에서는 값이 변경되엇지만 함수를 호출한 쪽(main)에서는 값이 변경되지 않았다. 지역변수 x 가 변경되지 않은 이유는 함수에 x 가 전달될 때 값에 의한 전달 방식으로 전달되었기 때문이다.

함수가 호출될 때 메모리에는 '스택 프레임'이 생긴다. 스택 프레임은 함수의 메모리공간 즉, 지역 변수가 존재하는 영역이다.

스택 프레임에는 함수를 호출한 다음 복귀할 주소 값 등 지역 변수 이외의 정보도 담고 있지만, 변수에 초점을 맞춰 살펴보자면, change_value() 함수의 스택프레임에는 x, value main() 함수에는 x 가 스택 프레임에 쌓여있다.

스택 프레임은 스택 메모리 공간에 생기는데 이 공간 역시 스택 자료 구조의 작동 원리를 따른다.
main()함수가 먼저 실행되므로 스택 프레임이 먼저 쌓이고 main()함수 안에서 호출한 change_value()함수의 스택 프레임은 그 위에 쌓인다.

main() 함수의 스택 프레임 공간에도 x 가 있고, change_value()함수에도 x 가 있다. 이 공간은 서로 독립된 공간이다. 인자를 전달할 때 main() 함수 스택 프레임의 지역변수인 x 를 전달한 것 같지만, 실제로는 change_value() 함수 스택 프레임의 지역 변수 x 에 값만 '복사' 한 것이다. 이처럼 인자를 전달 할 때 값을 복사해 전달하는 경우를 값에 의한 전달(call by value)라고 한다. 말 그대로 값을 복사할 뿐이다.

change_value()함수에서 x 에 value 값을 대입했으므로 x 값은 20 이다. 서로 다른 변수이기 때문에 mian() 함수의 지역변수 x 값은 변하지 않았다. change_value()함수는 change_value 스택 프레임의 지역 변수 x 의 값인 20 을 출력하고, 실행이 끝나면 스택 프레임은 사라진다.

그렇다면 함수 호출로 x 값을 바꿀 수 있는 방법은 없을까? 참조에 의한 전달 방식으로 인자를 전달하면 된다.

#### 참조에 의한 전달(call by reference)

```c++
#include <iostream>
using namespace std;
void change_value(int *x, int value)
{
  *x = value;
  cout << "x: "<<x<<"in change_value" <<endl
}
int main(void)
{
  int x = 10;
  change_value(&x, 20);
  cout << "x:"<<x<<"in main"<<endl;

  return 0;
}
// x : 20 in change_value
// x: 20 in main
```

main() 함수에서 &x 로 인자를 전달한다. 이는 main() 함수 스택 프레임의 변수 x 가 위치한 메모리 공간의 첫 번째 바이트 주소 값을 전달한다는 의미이다. 즉, 값 10 을 전달하는 게 아니라 데이터 10 을 저장하고 있는 4 바이트 공간(int 형은 정수형 자료형으로 4 바이트를 차지합니다)중 첫 번째 바이트의 주소 값을 전달합니다.

\*x 는 포인터 변수를 의미한다. 포인터 변수도 다른 변수처럼 데이터를 저장한다. 단지 그 데이터가 메모리 주소일 뿐이다. change_value() 함수 스택 프레임의 포인터 변수 x 는 &x 를 통해 전달된 main()함수 스택 프레임 안의 지역변수 x 의 주소 값을 저장한다.

포인터 변수가 주소 값을 저장한다는 것은 change_value 스택 프레임 안에 있는 int 형 포인터 x 가 화살표를 따라 main()함수의 지역변수 x 를 가리키는 것과 같은 의미이다.
가리킨다는 말은 다른 말로 풀이하면 참조(reference)이다. 이렇게 인자로 변수의 참조를 전달하는 방식을 **참조에 의한 방식**(call by reference)라고 한다.

파이썬은 함수에 인자를 전달할 때 값에 의한 전달 방식이나 참조에 의한 전달 방식을 사용하지 않고 '객체 참조에 의한 전달' 방식을 사용한다.

#### 객체 참조에 의한 전달(파이썬) - 변경 불가능 객체를 전달할 때

```py
def change_value(x, value): #3
  x = value #4
  print('x: {} in change_value'.format(x))


if __name__ == '__main__':
  x = 10 # 1
  change_value(x, 20) #2
  print("x: {} in main".format(x))

# x : 20 in change_value
# x : 10 in main
```

change_value() 함수를 호출하면서 인자로 #1 의 x 를 전달한다. 이떄 change_value 스택 프레임이 생성되면서 #3 의 인자 x 는 함수를 호출한 영역에 있는 #1 의 x 를 참조한다.
파이썬의 변수는 c 언어처럼 변수라는 메모리 공간에 값을 직접 저장하지 않는다. 변수 이름이 값 객체를 가리킨다.

파이쎤 역시 참조에 의한 전달 방식을 쓰는 것처럼 보이지만 출력 결과를 보면 아니라는 것을 알 수 있다.

상수 객체는 변경 불가능한 객체이다. 변수 값을 바꾼다는 의미는 변수 이름이 가리키는 메모리 공간의 값을 직접 바꾸는 게 아니라 **바꾸고자 하는 상수 객체를 참조**하는 것이다. #4 는 x 의 value 가 가리키는 상수 객체를 참조하게 하는 코드이다.

change_value() 스택 프레임이 사라지면서 change_value() 함수의 지역 변수 x 와 value 가 사라졌다. 또한 레퍼런스 카운트가 0 이 된 상수 객체 20 도 사라진다. x 를 출력하면 10 이 나온다.

**레퍼런스 카운트?**
메모리 영역 중에 힙(heap)이라는 공간이 있다. c/c++에서는 힙에 할당한 메모리는 프로그래머가 직접 해제해야 한다. 하지만 자바, c#, 파이썬 등에서는 메모리를 프로그래머가 직접 관리하지 않고 해당 언어가 스스로 해체해야 한다. 더는 사용하지 않는 메모리를 언어 차원에서 해제한다는 개념을 가비지 컬렉션(garbage collection)이라고 한다.

프로그래밍 언어에서 가비지 컬렉션을 구현하는 방법에는 가장 단순한 형태인 market and sweep 부터 가장 빠르다고 알려진 stop and copy, reference counting 등 가비지 컬렉션을 구현하는 알고리즘은 여러 가지가 있다.

파이썬은 레퍼런스 카운팅으로 가비지 컬렉션을 구현한다. 여기서 레퍼런스는 참조 즉, 무엇인가를 가리킨다는 의미이다.
예를 들어 변수 a 가 10 을 가리킨다고 가정하면 가리키는 대상의 개수인 레퍼런스 카운트는 1 이다. 이때 b = a 라는 코드를 입력하면 변수 b 도 10 이라는 객체를 가리키게 된다. 그러면 상수 객체 10 의 레퍼런스 카운트는 2 가 된다. a 와 b 가 10 이 아닌 서로 다른 객체를 가리키도록 코드를 수정하면, 상수 객체 10 은 레퍼런스 카운트가 0 이 되고 메모리에서 해제된다.

```py
import sys
a = 'abcd'
sys.getrefcount(a)
# 2
b = a
sys.getrefcount(a)
# 3
```

1 이 아닌 2 인 이유는 getrefcount() 함수가 실행되면서 'abcd'라는 문자열 상수를 참조하기 때문이다.

#### 객체 참조에 의한 전달(파이썬) - 변경 가능 객체를 전달할 때

변경 가능한 객체인 리스트를 인자로 전달해보기

```py
def func(li):
  li[0] = 'hello!'
if __name__ == '__main__':
  li = [1,2,3,4]
  func(li)
  print(li)
# ['hello!', 2,3,4]
```

- 참조한 리스트에 접근해 변경 시도
- func 스택 프레임의 li 와 main 스택 프레임의 li 가 모두 같은 메모리 공간을 참조한다.
- 리스트는 변경 가능한 객체이다.
- 첫번째 요소 값을 변경할 때 값 객체만 새로운 공간에 만들어 참조하면 된다.(파이썬은 스택 프레임에 직접 값을 저장하지 않으므로 요소들은 값 객체를 참조한다. )
- 값을 변경하기 위해 리스트 자체를 다른 메모리 공간에 새로 할당할 필요가 없다.

```py
def func(li):
  li = ['hello!',2,3,4]
if __name__ == '__main__':
  li = [1,2,3,4]
  func(li)
  print(li)
# [1,2,3,4]
```

- 아예 다른 리스트를 메모리 공간에 새로 만든 다음 이를 참조해 리스트를 변경
- 요소가 아니라 리스트 자체를 변경하였다. 이 경우에는 함수 호출이 끝나면 func 스택 프레임은 사라지면서 새로 만들어진 리스트는 삭제된다.

**정리**

- 함수 인자로 변경 불가능 객체를 전달해 값을 변경할 수 없다. 그 이유는 함수 안에서 새 객체를 만든 다음 참조하여 바꾸려 하면 함수 호출이 끝나고 스택 프레임이 사라지면서 참조도 사라지기 때문이다.
- 함수 내부에서 객체를 새롭게 할당해야만 값을 변경할 수 있는 객체는 변경 불가능 객체인 상수, 문자열, 튜플뿐이다.
- 리스트나 딕셔너리 같은 변경 가능 객체도 함수 아네서 새로운 객체를 만들 경우 함수 호출이 끝나면서 객체는 사라진다.
- 그러므로 변경 가능 객체를 인자로 전달할 때도 인자로 전달된 객체에 접근하여 변경해야만 함수를 호출한 쪽의 객체를 변경할 수 있다.
- 이러한 파이썬 인자 전달 방식을 객체 참조에 의한 전달 방식이라고 한다.

### 람다 함수

람다(lambda)함수는 이름이 없는 함수이다. 이름이 없기 때문에 다음 행으로 넘어가면 다시 사용할 수 없다.
자주 사용할 함수가 아니라면 필요할 때 람다 함수로 만들어 사용하면 된다.

```py
li = [i for in range(1,11)]
li
#[1,2,3,4,5,6,7,8,9,10]
li.sort(key = lambda x: x%2 == 0)
li
# [1,3,5,7,9,2,4,6,8,10]
```

f 로 람다 함수를 참조하면 이후 f 를 함수처럼 사용할 수 있다.

```py
f = lambda x: x ** 2
f(2)
# 4
```

람다 함수는 값을 반환하는 return 문이 없다. 또한 람다 함수의 몸체에는 반드시 식이 들어가야 한다.

```py
f1 = lambda li, idx: li[idx]
f2 = lambda li, idx: li[idx] = value
SyntaxError: can't assign to lambda
```

f2 는 람다 함수 몸체에 있는 li[idx] = value 가 식이 아닌 할당문이기 때문에 오류가 발생하였다.

# 내일 할 일

오늘 배운 함수에 대해서 다시 읽어보고 알고리즘 공부 하기!
