# 값 다루기 

## 값과 리터럴 
+ 프로그래밍 언어에서 값을 생성하는 방법이다. 
+ literal은 값이 아니라, 값을 표현하는 표기법이다. 
+ type정보가 같이 저장된다. 

```js
1; // 정수 리터럴
2.5; // 부동 소수점 리터럴
'hello'; // 문자열 리터럴
true; // 진리값 리터럴
```
## 변수
+ 값을 재사용하기 위해 값에 붙일 이름을 **선언**하고 그 이름에 값을 **대입**할 수 있다. 
+ 이름에 값을 연결시켜주는 작업을 **대입**이라고 한다. 
+ let 
  + let 은 변수를 선언할 때 쓰는 키워드이다. 
  + 변수의 선언이 끝난 이후에 대입을 하거나, 이미 값이 대입되어 있는 변수에 다른 값을 대입할 수도 있다. 
```js
let eight;
eight = 8;
let seven = 7;
seven = 77;
seven = 777;
```
+ const
  + 재대입이 불가능한 변수를 선언할 때 쓰는 키워드이다. 
  + const로 변수를 선언할 때는 반드시 선언 시에 값을 대입해주어야 합니다. 
  + 값 없이 선언만 하게 되면 에러가 발생한다.
  + 추후에 다른 값을 대입할 수 없다. 

+ let과 const로 선언한 이름은 다시 선언될 수 없다.

```js
let seven = 7;
let seven = 77; // Uncaught SyntaxError: Identifier 'seven' has already been declared
```
+ 특별한 이유가 없다면, let 보다 const를 사용하는 것이 좋다. 

## 식별자 
+ 변수의 이름은 모두 식별자이다. 
+ 식별자의 규칙 
  + 숫자, 알파벳, 달러 문자($), 언더스코어(_)가 포함될 수 있다.
  + 단, 숫자로 시작되어서는 안 된다.
  + 예약어는 식별자가 될 수 없다.
  + 한글이 포함된 식별자는 되도록 쓰지 않는 것을 추천한다. 

## camel case 
+ 식별자에 들어가는 각 단어의 첫 글자를 대문자로 써 주는 방식이다. 

## 타입 
+ 프로그래밍 언어는 여러 가지 종류의 값을 지원하는데, 이러한 값의 종류를 가지고 자료형이라고 부른다. 
+ 줄여서 타입이라고 부르기도 한다. 
+ 값의 타입을 알아보기 위해 `typeof`연산자를 사용할 수 있다. 


# 함수 
`const multiply = (x, y) => x * y;`

# 표현식 
+ 값으로 변환될 수 있는 부분은 다 표현식이다. 
  + "hello" === "hello" 3가지의 표현식 
+ literal을 연산자와 결합하는 것이 표현식이다. 

# 함수
+ 함수
+ 함수의 이름
+ 매개변수
+ 반환값 
+ 함수의 호출 (이미 정의되어있는 함수를 실행시키는 것) call 

`const multiply = (x, y) => x * y;`

# 객체 
+ 통 또는 자료구조라고 부른다 .
+ 객체에는 이름에 값이 연결되어 저장된다. 이름-값 쌍 (name-vlue pair)  
+ 혹은 객체의 속성(연결되어있는 두 개를 한꺼번에)이라고 한다. 속성이름-속성값 
+ 객체도 값이다. 변수에 대입할 수 있다. 

# 배열 
+ 가장 많이 쓰이는 통, 배열과 객체 
+ 객체에 담는 데이터는 속성이고 배열은 요소 혹은 항목이라고 부른다.
+ 배열에는 순서가 존재한다. 객체는 순서가 없다. 
+ 이름 대신에 인덱스를 이용해 값에 접근한다. 
+ 배열을 쓸 때는 메소드를 써서 조작을 한다. 

# ES6
+ 최신버전 자바스크립트 
+ 트랜스파일러, 폴리필로 환경에 맞게 변환한다.  

# 반올림 오차 
+ 컴퓨터는 소수도 이진수로 저장하기 때문에 입력숫자와 저장숫자의 오차가 있다. 
+ 이렇게 해야 계산히 빠름 컴푸터는 이진수로 숫자를 다룰 때 엄청나게 빨라진다. 
+ 정확도를 희생하는 대신 속도를 높인다.  
+ 정확하게 실수를 다루기 위해서는 라이브러리가 있다. 
 
+ 부동소수점: 떠있다는 뜻  floating point 
+ 고정소수점: fixed point 

# NaN
`NaN === NaN // false`
+ NaN과 같은 숫자는 없다. 
+ NaN에 어떤 연산을 하여도 NaN이 나온다. 
+ NaN이 하나라도 들어가면 다 NaN이 되니까 주의해야 된다. 버그가 생길 수 있으니 주의해야 한다. 
+ prompt 를 쓰면 Number.isNaN()을 무조건 쓴다고 생각하면 됨

```js
if(!Number.isNaN(V)){
  console.log("올바른 값을 입력하세요");
}
```
