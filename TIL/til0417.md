til 04/17/화요일 

# 1.값 더 알아보기

 ## 1-1.스코프 

```js
function fun(){
  for(var i = 0; i < 10; i++){
    //...
  }
  console.log(i)
  //var 변수는 유효범위가 함수전체인 함수스코프를 갖는다.  
}
func();
console.log(i) // 오류
```
## 1-2.호이스팅
+ var로 선언된 변수는 내부적으로 함수 혹은 파일의 맨 위로 끌어올려지는 과정을 거치기 때문에, 같은 스코프 안에만 있다면 변수가 선언되기 전에도 해당 변수에 접근할 수 있다. 
+ 이런 현상을 호이스팅이라고 한다. 

```js
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
 // 위의 코드를 자바스크립트는 변수선언을 내부적으로 함수 혹은 파일의 맨 위로 끌어올린다. 
// 내부적으로 아래 코드같은 과정이 일어난다. 
var foo;
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
// 변수 선언은 맨 위로 끌어올려지고 대입은 그 자리에서 일어난다. 
```
+ var 변수는 함수 스코프를 갖는다. 이는 함수가 아닌 블록에서 정의된 변수는 해당 블록 밖에서도 유효 할 수 있다. 
```js
for (var i = 0; i < 3; i++) {
  console.log('outer');
  // 위아래 두 `i` 변수는 같은 함수 스코프에서 정의된 같은 변수입니다.
  // 바깥쪽 루프를 한 번 도는 동안, 안쪽 루프를 도느라 이미 `i`의 값이 3이 되어버렸다. 
  for (var i = 0; i < 3; i++) {
    console.log('inner');
  }
}
// var 가 아닌 let 으로 선언하면 i 는 별개의 변수가 된다. 제대로 작동하게 된다. 
```
+ 스코프가 좁아지면 코드를 작성하기가 쉽다. 
+ 버그가 생기지 않도록 할 수 있다. 
+ 개발자가 신경써야 하는 코드의 범위가 줄어든다.
+ var 변수는 쓰지 말자, 되도록 const를 쓰고 꼭 필요한 경우라면 let을 쓰자. 

# 전역 변수 
+ 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프이다. 

# 전역객체 
+ JavaScript 구동 환경은 모두 전역 객체(Global Object)라는 특별한 객체를 갖고 있다. 
+ 전역 변수가 선언되면, 이 변수는 또한 전역 객체의 속성이 되어 전역 객체를 통해서도 접근할 수 있게 된다. 

```js
let foo = "hello";
window.foo;
```
`window.alert`
`window.prompt`

# 참조 
JavaScript에는 모두 일곱 가지의 타입이 존재한다. 
여기서 타입은 typeof 와는 다른 개념이다.
`typeof null // object `
null은  null 타입이다. 

+ 참조타입과 원시타입으로 분류한다. 
+ 객체를 제외하고는 모두 원시타입이다. 
+ 객체는 참조타입이다. 
+ 참조란 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값, 화살표 

+ 우리가 객체라고 생각하고 다루어왔던 값은 실제로는 객체에 대한 참조이다.

`const obj = {}; // 변수 `obj`에는 객체에 대한 참조가 저장되었습니다.`

+ 역참조 가서 가져온다. 
+ 화살표를 따라가서 객체를 본 뒤에 prop이 있으면 가져온다. 

# 함수 호출 
+ 함수 호출 시에는 인수가 복사되어 매개변수에 대입된다. 
+ 만약 함수 호출 시에 객체를 인수로 넘긴다면, 이 때 역시 실제로 복사되는 것은 객체가 아니라 참조이다. 
+ 참조를 이용해 원본 객체의 내용을 변경할 수 있다. 
+ 원본이나, 복사된 참조나 같은 객체를 가리키기 때문이다. 

```js
const obj = {};
//객체와 참조를 생성해서 객체는 어딘가에 있고 obj변수에는 화살표(위치)를 저장하는 것이다. 
function addProp(o) {
  o.prop = 1;
 }
// o 에 들어있는 화살표를 통해서 객체에 접근함 
// o = 1을 하더라도 obj는 빈객체가 들어있음 
// 화살표를 통해서 속성을 변경할 수 있지만, 변수에 연결되어있는 값 자체를 바꿔버릴 수는 없다. 

// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.
addProp(obj);
//객체가 매개변수로 넘어간다는 것 객체 안에 들어있는 속성은 자유롭게 변경할 수 있다. 
// obj화살표가 복사되어 0이라는 매개변수에 들어가는 것임.
// o 에 저장된 화살표 
console.log(obj.prop); // 1

// 변수 통이 들어가는 것이 아니라 값이 복사되어 함수가 실행이 됨  a에는 영향을 미치지 않음 
// 매개변수에 값을 '대입'해도, 원래 변수에는 아무런 영향도 미치지 못한다. 
let a  = 1;
function reassign(x){
  x = 2;
}
reassign(a);
console.log(a);
// 값이 복사되어서 매개변수에 전달되는 것이지,
// 변수 자체가 매개변수에 전달되는 것이 아니다. 
// 그래서 매개변수에 값을 대입해도 
// 아무런 영향도 미치지 못한다. 
// const a = 1을 써도 문제가 없다. 

```
+ call by reference 
+ 자바스크립트는 call by value가 아니라 항상 참조에 의한 호출인 call by reference이다. 

```js
john1 === john2; // false 참조비교
john1.isEqual(john2); // true 객체의 내용비교 
```
객체의 참조를 비교하는 것과 객체의 내용을 비교하는 것은 다르다.

# 불변성 

```js
const arr = [];
arr.push(1);
console.log(arr);
const str = "hello" 
```
+ 원시타입은 무슨 직을 해도 값 자체를 바꿀 수 없다.
+ 문자열을 바꾸려면 새로 문자열을 만든다음에 재대입을 하는 방법밖에 없다. 
```js 
 const newStr = "";
 newStr += "hi";
```
+ 원시 타입을 인수로 함수를 호출할 때에는, 원본이 변경될지도 모른다는 걱정을 할 필요가 없다.
+ 값이 불변일 뿐더러, 애초에 함수 호출 시에는 값이 복사되어서 전달되기 때문에 원본을 변경할 수 있는 방법이 아예 없다.

+ 객체는 가변이다. 
+ const는 변수 재대입을 막는 것이다. 재대입만 불가능할 뿐, 가변한다. 
+ 불변성은 값 자체가 변하지 않는다. 변수와는 상관없이 값 자체에 대한 것이다. 

# 래퍼객체 
+ 원시타입의 값은 객체가 아님에도 불구하고, 원시 타입에 점 표기법을 써서 메소드를 호출 하거나 속성을 읽어올 수 있다. 
+ 원시 타입의 값에 대해 속성을 읽으려고 시도하면, 그 값은 그 순간에만 객체로 변환되어 마치 객체인 것처럼 동작한다. 
```js
String.prototype.toUpperCase
'hello'.toUpperCase
```
생성자의 프로토타입 속성안에 toUpperCase있기 때문에 사용할 수 있다.  

`const str = new String('')`
`!!str `
빈문자열이 아니라, 객체이다. 
직접 객체를 생성시키는 경우는 거의 없다. 







